########################################################################
#
# This example demonstrates that brasfiles in different directories
# enclose their rules and commands in different namespaces.
# 
# Run as ../../bras or (after installation) as bras. Read this file to
# see why the output is as it is.
#
# (C) 2001, 2002 Harald Kirsch
# $Revision: 1.1 $, $Date: 2001/12/30 08:56:25 $
########################################################################


# In versions before 2.0, this variable would end up in the global
# namespace. Since 2.0, this very file is executed in an anonymous
# (read: autogenerated) namespace tied to the current directory. Care
# is taken that all predicates (i.e. the rules' tests) as well as all
# commands defined for the rules are executed in that namespace.
#
# The goal of introducing a separate namespace for every directory is
# to allow directory-local definitions of variables which tend to be
# used in many directories, like SRC, OBJ, SUBDIR.
#
# To use global variables, since 2.0 it is necessary to explicitly
# mark them as global, i.e. like ::CFLAGS

# A directory local variable.
set SRC {this.c that.c otherstuff.c}

# Another one which is later copied into the the namespace for subdir
# (see subdir/brasfile)
getenv CFLAGS {-g -Wall -W}


# The main target first delegates work to the subdirectory. Then the
# predicate p, defined below, is called. Its sole purpose is to print
# information about its execution environment. 
#
# When you run bras, you will first see the how the brasfile in subdir
# is executed, then predicate [p] will speak up before the command
# itself will make itself known after "--- MAIN ---"
#
# Please read also subdir/brasfile.
#
Make all {[or [updated @subdir/main_in_subdir] [p main]]} {
  showns 1 "--- MAIN ---"
  puts "SRC available as [namespace which -variable SRC]"
}


namespace eval ::bras::p {
  namespace export p

  # We define a predicate the main purpose of which is to list its own
  # execution environment. It always returnes 1. In addition, it shows
  # how a predicate leaves a value (in variable trigger) in the calling
  # environment for the command to pick it up.
  proc p {value} {
    ::showns 2 "within predicate"
    installPredicate [list trigger] {}
    set trigger $value
    return 1
  }
}


# A simple global function to list the execution environment $level
# levels up the stack.
namespace eval :: {
  namespace import ::bras::p::p

  proc showns {level msg} {
    set cns [uplevel $level [list namespace current]]
    puts "$msg {"
    puts "  directory = [pwd]"
    puts "  current namespace is $cns"
    puts "  it contains the following variables:"
    foreach x [info vars [set cns]::*] {
      set t [namespace tail $x]
      if {[catch {puts "    $t = [set $x]"}]} {
	puts "    $t (array)"
      }
    }
    puts "}"
  }
}



